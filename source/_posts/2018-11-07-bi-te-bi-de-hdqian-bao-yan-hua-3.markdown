---
layout: post
title: "比特币的HD钱包演化-3"
date: 2018-11-07 19:59:04 +0800
comments: true
categories: blockchain
styles: data-table
---

通过前面两篇文章，我们认识到比特币的所有权是通过私钥来确定的。

那么我们就在此基础上研究比特币钱包的构成。广义上，钱包是一个应用程序，为用户提供交互界面。钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易。 狭义上，比特币钱包的核心就是对私钥的管理。

在比特币的历史发展中，钱包大致经过了三次进化:

1. 非确定性（随机）钱包

2. 确定性（种子）钱包

3. 分层确定性钱包（HD Wallets (BIP-32/BIP-44)）


下面我们就好好说说钱包的历史发展轨迹:

<!-- more -->

## 非确定性（随机）钱包

在比特币刚诞生时，Bitcoin Core客户端实现了第一个钱包功能，当时因为早期的用户并不多且都是专业人士，钱包只是随机生成的私钥集合。这种类型的钱包被称作零型非确定钱包。具体的实现细节就是:
比特币核心客户端预先生成100个随机私钥，从最开始就生成足够多的私钥并且每个密钥只使用一次；

这样做的缺点十分明显：

如果你生成很多私钥，你必须保存它们所有的副本。这就意味着这个钱包必须被经常性 地备份。每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址重复使用将多个交易和地址关联在一起，这会减少隐私。

当比特币用户群逐渐扩大时，不少人因为随机生成的100个私钥用完后，没有备份老钱包，生成新的私钥后原先的钱包弃用，造成了未花费币的丢失。现在看看是个不可思议的幼稚的BUG，但是在比特币蛮荒时代，这种漫不经心的错误导致的丢币比比皆是。


## 确定性（种子）钱包

比特币私钥可以用任意方法生成，自然也可以通过一个随机短语进行多次hash得到不同的私钥。这种思路下，社区提出了确定性（种子）钱包的方案。

确定性，或者“种子”钱包包含通过使用单项离散函数而可从公共的种子生成的私钥。种子是随机生成的数字。在确定性钱包中，种子足够恢复所有的已经产生的私钥，所以只用在初始创建时的一个简单备份就足以搞定。并且种子也足够让钱包导入或者导出。这就很容易允许使用者的私钥在钱包之间轻松转移。

比如，我们上一篇文章中用`satoshi`作为种子，得到SHA256('satoshi')作为私钥，完全可以继续用SHA256(SHA256('satoshi'))...这样推导下去得出更多的私钥，同时，只需要记住`satoshi`这个种子，就可以方便的导入导出私钥。更进一步，可以加入password和更多的混淆短语，提高私钥生成的健壮性。

这种方案提出后，因为简单易行，多个轻钱包都做了自己的实现；虽然原理相似，但是他们之间并不通用，所以不同的钱包私钥导入导出还有一些不方便。社区就在此基础上继续探索，最终整理形成了BIP32、BIP39、BIP43，BIP44等规范，创造了我们今天通用的HD钱包。

## 分层确定性钱包（Hierarchical Deterministic wallet--HD Wallet）

首先用一张经典的图来描述HD钱包的私钥生成:

![img](http://upload-images.jianshu.io/upload_images/1785959-7ce3000da8239b74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

分层钱包说白了，就是将`seed->私钥`的过程变成了，`助记词->seed->一级私钥->二级私钥->三级私钥....`，即多层树状私钥生成的方案。HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。HD钱包有两个主要的优势。

1. 树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。

2. 是它可以允许让使用者去建立一个公共密钥的序列而不需要访问相对应的私钥。这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。公共钥匙不需要被预先加载或者提前衍生，而在服务器中不需要可用来支付的私钥。


再来一个在线工具用于验证:

https://iancoleman.io/bip39/


最初的私钥seed来源于一个助记词（又称为Mnemonic Code），为了便于在不同的钱包中转移、导出和导入，社区对助记词的长度，范围，变换标准等等做了详尽的描述，最终形成了[BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)规范。这个规范由Trezor硬件钱包背后的公司提出，已经成为事实上的行业标准。

BIP-39定义了助记符码和种子的创建，我们在这里描述了九个步骤。 为了清楚起见，该过程分为两部分：

1-6步是创建助记词，7-9步是从助记词到种子。下面我们从一个`ffffffffffffffffffffffffffffffff` 的128bits 熵开始，演示HD钱包是如何生成、管理私钥的。让我们一步一步解释。

#### 先看看创建助记词的部分

1、创建一个128到256位的随机序列（熵）。我们取`ffffffffffffffffffffffffffffffff`，称之为原始熵。

2、用SHA256 HASH原始熵，就可以创造一个随机序列的校验和。代码如下

```
from binascii import unhexlify
from hashlib import sha256
data = 'f' * 32
data_unhexlify = unhexlify(data)
h = hashlib.sha256(data_unhexlify)
checksum = bin(int(h, 16))[2:].zfill(256)[:len(data) * 8 // 32]
```

得到checksum为`0101`

3、首先求得原始熵的二进制表示，然后将校验和添加到随机序列的末尾。代码如下:

```
from binascii import unhexlify, hexlify
data = 'f' * 32
data_unhexlify = unhexlify(data)
body = bin(int(hexlify(data), 16))[2:].zfill(len(data) * 8)
final_result = body + checksum
```
得出的结果为

```
111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110101
```

4、将序列划分为包含11位的不同部分。

```
11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111111111 11111110101
```

5、将每个包含11位部分的值作为下标索引，与一个已经预先定义2048个单词的字典做对应。BIP39中对应的字典文件可以参考这里:

https://github.com/trezor/python-mnemonic/tree/master/mnemonic/wordlist

以上二进制表示的下标值为:

```
2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2047, 2037
```

6、生成的有顺序的单词组，就是助记码(Mnemonic Code)。在咱们的例子中如果采用英文字典，对应的结果为:

```
zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong
```


一张图展示熵如何生成助记词:

![img](http://upload-images.jianshu.io/upload_images/1785959-bed496243dd75389.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


在上面这个例子中，我们选取了128Bits 原始熵，BIP39规范中，用户有128bits, 160bits, 192bits, 224bits, 256bits多个选择;下面的表格说明了熵数据的大小和助记词的长度之间的关系:


Entropy(bits) | Checksum(bits)| Entropy + checksum(bits) | Mnemonic length(words)
---|---|---|---
128|4|132|12
160|5|165|15
192|6|198|18
224|7|231|21
256|8|264|24

目前最流行的实现还是跟我们上面的例子一样，选取128bits->12words 的Mnemonic code生成。

#### 从助记词生成种子

现在我们已经从`ffffffffffffffffffffffffffffffff`随机熵得到了助记码`zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong`，现在需要从助记码再生成种子。

这里我们需要先介绍一个函数:PBKDF2，它被称之为密钥延伸函数。作用是 ~~ 待续
