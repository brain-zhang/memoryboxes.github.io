---
layout: post
title: "比特币的blockchain-1"
date: 2019-01-21 17:44:54 +0800
comments: true
categories: blockchain
styles: data-table
---
blockchain是个新造词，至少在2008年之前网上是搜索不到这个词的；

比特币的白皮书里面出现过`chain of blocks`的描述，但是没有直接用`block chain`的句子;

在早期bitcointalk.org上面的讨论中，为了方便讨论，早期参与者频繁引用`chain of blocks`的主题，但是谁是最早的引用者，已不可考据。

如果真正要较真blockchain这个单词第一次出现的地方，我想大概是中本聪的第一版bitcoin 源代码中；

bitcoin v0.01源代码中，中本聪第一次在[函数注释中](https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.h#L596) 完整的引用了`block chain`这个术语，鉴于中本聪在比特币白皮书发表的2年前已经开始编写源码；所以有理由确认：

1. blockchain这个名词是2007-2008年间诞生于世间的
2. 中本聪是比特币之父，比特币是blockchain之母

现在有一种说法，是比特币和区块链是不同的，比特币是个没有什么前途的庞氏货币，而区块链作为一种新兴的基础技术将会在很多领域发扬光大，前景光明；

对于这个说法，我认为Andreas的一场演讲值得一看：

https://www.youtube.com/watch?v=SMEOKDVXlUo

<!-- more -->

好了，八卦完毕，我们开始探究比特币里面的blockchain究竟是个什么样的技术，它是解决什么问题的，实现细节是怎样的；

然后我们一贯的风格是:`光说不练假把式`；在原理说明中，我们会用代码parse真正的比特币区块链文件来一探究竟。

## 由来

还记得我们[之前的文章](https://happy123.me/blog/2018/11/23/bi-te-bi-de-jiao-yi-1/)里面提到的，如果要建立一个分布式的账本，要解决两个问题:

1. 什么样的交易是一笔合法的交易
2. 哪个节点有记账的权力，如何保证整个账本是唯一且不可篡改的

我们在比特币交易的系列文章中解答了第一个问题，现在是解决第二个问题的时候了。

先思考一下货币发行的问题，比特币网络中，会有成千上万的节点参与者，哪些节点能获得发币的权利呢？或者说，凭什么这些节点能有记账权呢？

在金银货币时代，发币是通过开采金矿来实现的；采矿者承担了勘探、挖掘的风险，大家认可其开采成果并承认其铸币权；那么映射到电子世界中，能不能有一种类似的挖矿的机制呢？

中本聪的回答就是POW (proof of work--工作量证明)；全网的所有节点一起算一个毫无意义的随机数字，这个数字满足以下的条件，凡是能算出这个数字的人，我们就承认他有一次的记账权：即一次铸币的权利；这个条件如下：

#### 在一个计算周期内，计算出来的这个数字R满足 F(Chain[R]) < Target；其中F是SHA256算法，Chain是账本，Target是不断减小的，这意味着寻找R的几率会越来越小

中本聪认为算力是非常公平的、不可伪造的一种证明手段；凡是能在规定周期内正确解答谜题的人，理应获得回报；所有加入到这个比特币网络的人，都应该承认这一点，如果你不承认，那比特币网络就不欢迎你；

那么，铸币的问题解决了；但是如何防止有的节点获取记账权之后，伪造账本呢？

答案是将POW的计算结果嵌入到账本中，每一次新周期的计算，其结果必须在之前所有计算结果的基础上完成；这样如果有人想要伪造账单条账目，他就必须在一个计算周期内伪造更多的账目；如果想要伪造整个账本，就需要将比特币创世之初到现在所有的POW重新计算一遍，而能够获得这样的算力，基本上是不可能的。

那么，如何将这个计算证明过程嵌入到账本里面呢？

答案就是每个计算周期生成一个block，这个block包含了这个周期内全网的交易，而Target就嵌入到这个block中，然后将block用HASH值作为指针串联起来，构造成一条坚不可摧的chain；这就是blockchain的由来。


## 区块结构

如果你运行最新版本的bitcond(>=v0.16)，会发现在数据目录有四类文件:

1. datadir/blocks/blkxxxxx.dat: 存储原始的区块数据，这就是我们常说的blockchain数据
2. datadir/blocks/index/xxxx.ldb: 区块的原始数据索引，有了它，我们就可以根据HASH值快速查找交易和区块
3. datadir/chainstate/xxx:这个目录中,存放着LevelDB中的UTXO记录,以及一些这些交易来源的元数据.这些数据用来校验收到的区块和交易
4. datadir/blocks/revxxxxx.dat: 在区块链分叉重组的时候需要用回滚记录去更新UTXO记录

1是原始区块数据，第2，3类数据可以从1中重建，但重建会花很长时间；在一台16Core, 32GB内存，SSD磁盘的机器上，大概要花1天左右。

第4类数据比较特殊，如果存储的数据已经落后了当前区块高度非常远的距离，其实可以删除的；但是为了保证 100%的严谨和安全，目前默认的实现还是全部保留。

3，4类数据在最初的比特币版本中，没有写入文件，就是内存里面放个MAP数据结构临时存着；后来交易量变大，多次代码重构后，变成了今天这个样子。

截至2019-01，以上数据加起来，已经超过了200GB。


那我们就主要来分析第1类数据，就是原始区块数据。

#### Block结构

一个block的结构异常简单，列表如下:


Size | Field | Description
---|---|---
4 bytes | Block Size | 当前block的大小
80 bytes | Block Header | block头信息
1-9 bytes (VarInt) | Transaction Counter | 这个block包含的交易数量
Variable | Transactions | 交易


如果去parse blkxxxx.dat 文件，按照这个结构就能很容易拆分出每一个block；来一个工具:

https://github.com/alecalve/python-bitcoin-blockchain-parser

另外值得注意的是，因为bitcoind写入区块文件的时候是并行的，所以按照字节序解析出来的区块并不是按时间顺序排列的，blkxxxx.dat文件中，区块存储的次序是随机的；

#### Block Header

区块头由三组区块元数据组成。

首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与区块链中前一区块相连接。就是我们前面讲的作为指针的HASH值。

第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关，本质上就是前面公式里面的R值和Target值。

第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构，我们在后面会介绍）。



Size | Field | Description
---|---|---
4 bytes | version | 当前协议版本 |
32 bytes | Previous Block Hash | 当前Chain上，前一个block的HASH值 |
32 bytes | Merkle Root | 这个block中所有交易的Merkle root key |
4 bytes | Timestamp | 当前block的创建时间 |
4 bytes | Difficulty Target | 当前block的POW难度值 |
4 bytes | Nonce | 这就是我们前面说的那个`毫无意义的随机数`，耗费巨大能源就是为了找到满足条件的Nonce |

PS:比特币客户端除了bitcoin core之外，任何团队都可以根据当前的协议开发自己的比特币软件，事实上当前也有不少其他的实现，而各个团队之间开发的不同客户端需要遵循同样的协议标准，这个协议的版本管理就是依靠开头的version字段，规则请参照[BIP009](https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki)


#### block标识符

block header中，我们有一个`Previous Block Hash`值，这就是我们所说的将block串联成为chain的指针。那么这个指针值是怎样计算出来的呢？

还是以[创世块](https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f)为例，让我们仔细研究下:

创世块的HASH值为`000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f`，这是一个32字节的HASH值，通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。注意，这个值仅仅是根据区块头得到的，即 `SHA256(SHA256(Block Header))`;

仅仅依赖区块头就够了吗？是的，不要忘了，我们在区块头里面还有一个重要的HASH值，就是`Merkle Root`，`Merkle Root`标识了block中所有的交易，而`block Hash` 通过HASH包含了`Merkle Root`的`block header`，唯一、明确地标识了一个区块，并且任何节点通过简单地对区块头进行哈希计算都可以独立地获取该区块哈希值。


另外需要注意的一点是: 区块哈希值实际上并不包含在区块的数据结构里，不管是该区块在网络上传输时，抑或是它作为区块链的一部分被存储在某节点的永久性存储设备上时。相反，区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。

当我parse block得到`previous block hash`值时，如何去判断存在上一个真正的block呢？一般都会到索引文件里面找，就是我们前面所说的 index/xxxx.ldb文件。

#### 区块高度

除了这个HASH值作为区块标识符，我们一般还会在区块浏览器上面看到一个说明`Height`；比如创世块的`Height`就是0；

这是程序员们按照block在chain上面的次序为block的编号，这个信息是不会写入blockchain的，只是作为`区块高度`在很多时候方便表示和计算；

当节点接收来自比特币网络的区块时，会动态地识别该区块在区块链里的位置（区块高度）。 区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。

和区块哈希值不同的是，区块高度并不是唯一的标识符。虽然一个单一的区块总是会有一个明确的、固定的区块高度，但反过来却并不成立，一个区块高度并不总是识别一个单一的区块。两个或两个以上的区块可能有相同的区块高度，在区块链里争夺同一位置。这种情况是怎样发生的呢？

因为一个全节点会时时刻刻接收全网的区块广播，在一个生产周期内，不可避免的，会产生两个或更多的符合条件的block，这个时候会发生什么呢？

所有区块高度相同的区块会争夺成为链接上chain的权利，此时所有的矿工便会收集所有可能的chain分支，并选取最长的那一条在上面继续挖矿。

如果把这个情景图像化，我们会看到blockchain时时刻刻都处在分叉状态中，新产生的block会在chain的末尾组成多个分支，就好像一条绳子的末端散开一样；

关于这个情景，有个很诗意的描述词：`HASH DANCE`；

作为一个Geek，这真是一场让人意醉神迷的数字之舞啊。


#### 创世区块

区块链里的第一个区块创建于2009-01-03 18:15:05 GMT，被称为创世区块(Genesis block)。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。

因为创世区块被编入到比特币客户端软件里，所以每一个节点都始于至少包含一个区块的区块链，这能确保创世区块不会被改变。每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为区块链的首区块，从而构建了一个安全的、可信的区块链。

创世块比较特殊，它不是挖出来的，是中本聪手工构造的；参见这里:

https://github.com/memoryboxes/bitcoin_satoshi/blob/v0.01/main.cpp#L1439


关于创世块，之前我们提到一个有趣的事情：创世块的50BTC奖励是不能花的，这是为什么呢？

这需要我们好好研究以下中本聪发布的v0.01版本的比特币源码：

https://github.com/memoryboxes/bitcoin_satoshi/tree/v0.01

1. 整个比特币系统接收一笔交易的时候怎么判断其合法性呢？就是判断这笔交易的vin是否关联着一笔合法交易的vout，这些vout统称UTXO，在初版比特币里面，判断一个合法的UTXO的标准就是有没有放进区块链的索引文件中；这个索引文件和区块链文件不是一个东西，他是单独的；如果你运行初版比特币软件(v0.01)；就可以看到中本聪把区块存储在blk0001.dat这样的文件里面，而把所有区块的索引存储在blkindex.dat这个文件里面；
2. 那么问题就出现了，blkindex.dat 什么时机才能写入呢？通读源码发现，只有自己挖矿挖到区块，或者收到周围的广播区块的时候，才有机会写入blkindex.dat这个文件;
3. 中本聪不知道有意无意，在前面手工构造创世区块的时候，没有构建索引写入blkindex.dat里面
4. 后来比特币的源码不断变迁，存储UTXO的方式由BDB变成了levelDB，但是创世块一直没有没有写入到索引文件里面，这样花费创世交易的时候，没有相应的索引，创世交易的UTXO就是非法的，所以没法花费

* 那么如何解决呢？有两个办法：

1. 就是把创世区块写到区块索引里面
2. 或者在检查交易合法性的时候，单独的加一个判断条件，判断UTXO是否出自创世区块

* 为什么迟迟没有修正：

1. 每个办法都需要一次硬分叉
2. 这需要全网节点都升级这个只影响创世块的50BTC，中本聪都不在乎，何苦为了50BTC就全网升级呢？
3. 最后，创世块见证着历史，其实不能花费挺好的。

#### coinbase

紧接着`block header`的，就是当前block的所有交易，其中第一笔交易就是coinbase 交易。关于coinbase交易，我们曾经在之前的文章中详细介绍过，这里就增加说明一点，coinbase交易的输出包括了所有交易的手续费，将来比特币网络的额定产出越来越少的时候，矿工们还是可以通过打包交易费用获利，来维持比特币网络的正常运转。

就当前的情况来看，再来一次减半，基本上交易费用和新区快产出就对等了。

#### 隔离见证

实施了隔离见证之后，对于`block header`和coinbase都有一些变化，我们以后会详细再提。


## 区块链接成为区块链

比特币的全节点在本地保存了区块链从创世区块起的完整副本。随着新的区块的产生，该区块链的本地副本会不断地更新用于扩展这个链条。当一个节点从网络接收传入的区块时，它会验证这些区块，然后链接到现有的区块链上。为建立一个连接，一个节点将检查传入的区块头并寻找该区块的“父区块哈希值”。

最后所有区块组成了blockchain:

![img](http://upload-images.jianshu.io/upload_images/1785959-778f551c409faeba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## Merkle树

#### SPV(简单支付)
